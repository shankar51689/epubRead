<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Smooth 3D Book Reader</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

    <style>
        body {
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column;
            background: #2b2b2b; font-family: 'Georgia', serif;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #toolbar {
            height: 60px; background: #1e1e1e;
            display: flex; align-items: center;
            justify-content: space-between;
            padding: 0 20px; z-index: 2000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
        }

        #toolbar button {
            background: #3a3a3a; color: #ddd; border: 1px solid #444;
            padding: 10px 20px; border-radius: 20px;
            cursor: pointer; font-size: 14px; font-weight: bold;
            transition: all 0.2s ease;
        }
        #toolbar button:active { transform: scale(0.95); background: #555; }

        #book-viewport {
            flex-grow: 1;
            position: relative;
            background: #252525;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            perspective: 2500px; /* Deep perspective for smoother 3D feel */
        }

        #viewer {
            width: 100%; height: 100%;
            background: #fdfaf5;
            z-index: 10;
            position: absolute;
            box-shadow: inset 20px 0 50px rgba(0,0,0,0.05); /* Static spine shadow */
        }

        /* ===== THE SMOOTH PEEL ===== */
        #page-peel {
            position: absolute;
            top: 0; 
            width: 100%; height: 100%;
            z-index: 100;
            pointer-events: none;
            display: none;
            background: #fdfaf5;
            will-change: transform, clip-path; /* GPU Acceleration */
            transform-style: preserve-3d;
            
            /* Realistic paper texture/spine */
            box-shadow: inset 5px 0 20px rgba(0,0,0,0.05);
        }

        #peel-gradient {
            position: absolute; inset: 0;
            will-change: opacity, background;
            /* Default gradient, updated via JS */
            background: linear-gradient(to left, transparent, rgba(0,0,0,0.1)); 
        }

        #drop-shadow {
            position: absolute; top: 0; width: 100%; height: 100%;
            z-index: 50;
            background: rgba(0,0,0,0.4);
            display: none; pointer-events: none;
            will-change: opacity, background;
        }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #888; z-index: 20;
            font-family: sans-serif;
            letter-spacing: 1px;
        }
    </style>
</head>

<body>

<div id="toolbar">
    <button onclick="autoFlip('prev')">◀ Prev</button>
    <div style="color:#666; font-size:12px; font-family:sans-serif">Slide or Click to Flip</div>
    <button onclick="autoFlip('next')">Next ▶</button>
</div>

<div id="loading">Opening Book...</div>

<div id="book-viewport">
    <div id="viewer"></div>
    <div id="drop-shadow"></div>
    <div id="page-peel">
        <div id="peel-gradient"></div>
    </div>
</div>

<script>
    let book, rendition;
    let isDragging = false;
    let startX = 0;
    let width = window.innerWidth;
    let animationFrameId;

    // Elements
    const peel = document.getElementById('page-peel');
    const peelGrad = document.getElementById('peel-gradient');
    const viewer = document.getElementById('viewer');
    const dropShadow = document.getElementById('drop-shadow');

    // Moby Dick (Reliable public domain source)
    const DEFAULT_BOOK = "https://s3.amazonaws.com/moby-dick/moby-dick.epub";

    function initReader(url) {
        book = ePub(url);
        rendition = book.renderTo("viewer", {
            width: "100%", height: "100%", flow: "paginated"
        });

        rendition.display().then(() => {
            document.getElementById('loading').style.display = 'none';
            setupGestures();
            rendition.themes.register("paper", { body: { background: "#fdfaf5", color: "#111" } });
            rendition.themes.select("paper");
        });
    }

    /* =========================================
       GESTURES
       ========================================= */
    function setupGestures() {
        rendition.on("touchstart", e => {
            if(animationFrameId) cancelAnimationFrame(animationFrameId); // Stop any auto animations
            startX = e.changedTouches[0].screenX;
            isDragging = true;
            width = window.innerWidth;
            peel.style.transition = 'none'; // Instant follow
            dropShadow.style.transition = 'none';
        });

        rendition.on("touchmove", e => {
            if (!isDragging) return;
            // Prevent default browser swipe nav
            e.preventDefault(); 
            
            const currentX = e.changedTouches[0].screenX;
            const diff = startX - currentX;
            
            // Direct 1:1 movement for responsiveness
            if (diff > 0) renderNextFrame(diff / width); // Dragging Left
            else renderPrevFrame(Math.abs(diff) / width); // Dragging Right
        });

        rendition.on("touchend", e => {
            if (!isDragging) return;
            isDragging = false;
            const diff = startX - e.changedTouches[0].screenX;
            const progress = Math.abs(diff) / width;

            // Velocity Check: If dragged more than 15% across, finish the flip
            if (diff > 0) { // Next
                if (progress > 0.15) smoothFinish('next', progress);
                else smoothReset('next', progress);
            } else { // Prev
                if (progress > 0.15) smoothFinish('prev', progress);
                else smoothReset('prev', progress);
            }
        });
    }

    /* =========================================
       CORE RENDERING (The Physics)
       ========================================= */
    
    // Render the "Next Page" Peel (Right -> Left)
    function renderNextFrame(progress) {
        progress = Math.max(0, Math.min(1, progress));
        
        peel.style.display = "block";
        dropShadow.style.display = "block";
        peel.style.transformOrigin = "center right"; 
        peel.style.left = "0"; peel.style.right = "auto";

        const clipX = 100 - (progress * 100);
        
        // 1. Clipping
        peel.style.clipPath = `polygon(0 0, ${clipX}% 0, ${clipX}% 100%, 0% 100%)`;
        
        // 2. Rotation & Translation (The "Curl" effect)
        // We translate slightly left and rotate deeply
        const rot = -progress * 25; 
        const trans = -progress * 40;
        peel.style.transform = `translateX(${trans}px) rotateY(${rot}deg)`;
        
        // 3. Shadow & Gradient Logic
        // Gradient creates the "roundness" of the fold
        peelGrad.style.background = `linear-gradient(to left, 
            rgba(0,0,0,0) ${clipX - 15}%, 
            rgba(0,0,0,0.15) ${clipX}%, 
            rgba(255,255,255,0.6) ${clipX + 2}%,
            rgba(255,255,255,0) ${clipX + 10}%
        )`;

        dropShadow.style.background = `linear-gradient(to right, rgba(0,0,0,0) ${clipX-20}%, rgba(0,0,0,0.6) ${clipX}%)`;
        dropShadow.style.opacity = Math.sin(progress * Math.PI); // Peak shadow in middle
    }

    // Render the "Prev Page" Peel (Left -> Right)
    function renderPrevFrame(progress) {
        progress = Math.max(0, Math.min(1, progress));

        peel.style.display = "block";
        dropShadow.style.display = "block";
        peel.style.transformOrigin = "center left";
        peel.style.left = "0"; 

        const clipX = progress * 100;

        // 1. Clipping (Growing from left)
        peel.style.clipPath = `polygon(0 0, ${clipX}% 0, ${clipX}% 100%, 0% 100%)`;
        
        // 2. Rotation (Lifting slightly)
        const rot = (1 - progress) * 15;
        peel.style.transform = `rotateY(${rot}deg)`;

        // 3. Shadows
        peelGrad.style.background = `linear-gradient(to right, 
            rgba(255,255,255,0) ${clipX - 10}%, 
            rgba(0,0,0,0.1) ${clipX}%, 
            rgba(0,0,0,0) ${clipX + 5}%
        )`;
        
        dropShadow.style.background = `linear-gradient(to right, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) ${clipX}%)`;
        dropShadow.style.opacity = Math.sin(progress * Math.PI);
    }


    /* =========================================
       ANIMATION LOOP (TIME BASED)
       ========================================= */
    
    // Easing function: Ease Out Cubic (starts fast, slows gently)
    const easeOutCubic = x => 1 - Math.pow(1 - x, 3);
    
    function autoFlip(direction) {
        width = window.innerWidth;
        const duration = 700; // ms
        const startTime = performance.now();

        function animate(time) {
            let timeFraction = (time - startTime) / duration;
            if (timeFraction > 1) timeFraction = 1;

            const progress = easeOutCubic(timeFraction);

            if (direction === 'next') renderNextFrame(progress);
            else renderPrevFrame(progress);

            if (timeFraction < 1) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                if (direction === 'next') finalizeNext();
                else finalizePrev();
            }
        }
        animationFrameId = requestAnimationFrame(animate);
    }

    // Handles the "Let go" physics
    function smoothFinish(dir, currentProgress) {
        const remaining = 1 - currentProgress;
        const duration = 400 * remaining; // Faster if closer to end
        const startTime = performance.now();
        const startVal = currentProgress;

        function animate(time) {
            let timeFraction = (time - startTime) / duration;
            if (timeFraction > 1) timeFraction = 1;

            // Lerp from current position to 1
            const newProgress = startVal + ( (1 - startVal) * easeOutCubic(timeFraction) );

            if (dir === 'next') renderNextFrame(newProgress);
            else renderPrevFrame(newProgress);

            if (timeFraction < 1) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                if (dir === 'next') finalizeNext();
                else finalizePrev();
            }
        }
        animationFrameId = requestAnimationFrame(animate);
    }

    function smoothReset(dir, currentProgress) {
        const duration = 300; 
        const startTime = performance.now();
        const startVal = currentProgress;

        function animate(time) {
            let timeFraction = (time - startTime) / duration;
            if (timeFraction > 1) timeFraction = 1;

            // Lerp from current position back to 0
            const newProgress = startVal - ( startVal * easeOutCubic(timeFraction) );

            if (dir === 'next') renderNextFrame(newProgress);
            else renderPrevFrame(newProgress);

            if (timeFraction < 1) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                peel.style.display = "none";
                dropShadow.style.display = "none";
            }
        }
        animationFrameId = requestAnimationFrame(animate);
    }

    /* =========================================
       FINALIZATION (The Logic Swap)
       ========================================= */

    function finalizeNext() {
        rendition.next().then(() => {
            // Flash-hide the peel once text is loaded
            peel.style.display = "none";
            dropShadow.style.display = "none";
            peel.style.clipPath = "none";
            peel.style.transform = "none";
        });
    }

    function finalizePrev() {
        rendition.prev().then(() => {
            peel.style.display = "none";
            dropShadow.style.display = "none";
            peel.style.clipPath = "none";
        });
    }

    // INIT
    const params = new URLSearchParams(window.location.search);
    const url = params.get("url") || DEFAULT_BOOK;
    initReader(decodeURIComponent(url));

</script>
</body>
</html>